/**
* E3 Timestamp Experiment Campaign Loader
*/

/*jslint white:true, vars:true, plusplus:true, nomen:true */
/*globals mw, $, murmurhash2_32_gc */

"use strict";

var VERSION = 1;

var bucket_name;

// Simple random sampling using murmurhash2
function inSample( key, fraction ) {

	if ( typeof key !== 'string' ) {
		throw new TypeError( 'key must be a string' );
	}
	if ( typeof fraction !== 'number' ) {
		throw new TypeError( 'sampling factor must be a number' );
	}
	if ( fraction > 0.01 ) {
		throw new RangeError( 'sampling factor cannot exceed 0.01' );
	}

	// murmurhash2_32_gc generates hashes in the 32-bit unsigned
	// integer range ( 0 - 2^32 ).
	var sample = fraction * 4294967296;  // 2^32
	var hash = murmurhash2_32_gc( key, 1 );
	return ( hash <= sample );
}

// Check sampling logic is working as expected
function isSamplingSane() {

	// Article ids known to be *in* the sample
	var sampled = [ 770302, 10931124, 8925406, 289739, 5941768,
	    6142699, 9335267, 59971, 965895, 943594 ];

	// Article ids known to be *outside* the sample
	var unsampled = [ 1662901, 607444, 1497317, 10485355, 788512,
	    866634, 190702, 866629, 190329, 190643 ];

	var i = 0;

	for ( i = 0; i < 10; i++ ) {
		if ( inSample( unsampled[i].toString(), 0.006 )
		     || !inSample( sampled[i].toString(), 0.006 ) ) {
			return false;
		}
	}

	return true;
}

// Proxy for $.trackAction which ensures
// 1) sampling is sane
// 2) the user has been bucketed
// 3) only one automatic event is ever emitted.
var trackAction = ( function ( e ) {
	// A counter of emitted events, wrapped in a closure to make it private
	var _events = 0;

	return function () {
		//
		// Safety Checks
		//

		// Has the user been bucketed?
		if ( !bucket_name ) {
			return false;
		}

		// Was an event defined?
		if ( !e ) {
			return false;
		}

		// Is sampling sane?
		if ( !isSamplingSane() ) {
			return false;
		}

		// Have we already emitted an event?
		if ( _events > 0 ) {
			return false;
		}

		_events++;
		$.trackAction.apply( $, arguments );
		return true;
	};
} () );


function generateEvent( event_type ) {
	var id = [ 'ext.lastModified', VERSION ].join('@');
	return [ id, bucket_name, event_type ].join('-');
}


// Determine whether the current view should display the experiment
function isEligible() {
	return (

		// The current user has not opted out
		mw.user.options.get('vector-noexperiments') !== "1"

		// We're on an article page
		&& mw.config.get( 'wgIsArticle' )

		// The article is in the main namespace
		&& mw.config.get( 'wgNamespaceNumber' ) === 0

		// The article is being viewed (not edited, printed, watched, etc.)
		&& mw.config.get( 'wgAction' ).match( /view|purge/ )

		// This isn't a redirect
		&& mw.util.getParamValue( 'redirect' ) !== 'no'

		// We're not in print view
		&& mw.util.getParamValue( 'printable' ) !== 'yes'

		// We're not viewing a diff
		&& mw.util.getParamValue( 'diff' ) === null
		&& mw.util.getParamValue( 'oldid' ) === null

		// Safety check: AFT isn't active
		&& mw.loader.getState( 'jquery.articleFeedbackv5.track' ) !== 'ready'
	);
}

// The space where we plop the timestamp is subject to contention by
// various other widgets, extensions and templates, so we need to
// inspect the dom and make adjustments to CSS according to what we
// discover.
function getStyleOverrides() {
	var overrides = {}, icon, offset;

	// Identifiy the leftmost top icon, if present, by passing
	// a custom comparison function to Array.sort.
	icon = Array.prototype.sort.call( $( '.topicon' ), function ( a, b ) {
		return $(a).position().left - $(b).position.left;
	} ).last();

	// If there are any top icons, we'l shift the timestamp to the
	// right of the leftmost one.
	if ( icon.length ) {
		offset = icon.parent().width() - icon.position().left;
		// As a sanity check, make sure we aren't offsetting by
		// more space than we have available.
		if ( offset < $('#bodyContent').width() ) {
			overrides['margin-right'] = offset;
			overrides['padding-right'] = 20;
		}
	}
	return overrides;
}

function trackTimestamp() {

	if ( !isSamplingSane() ) {
		return false;
	}

	$( function () {

		var uri;
		var el = $( '#mwe-lastmodified' );
		var a = $( 'a', el );
		var historyAnchor = $( '#ca-history a' );
		var newUrl;

		// Get the base history URI.
		// We prefer the one from the History tab since it is consistant,
		// but older MediaWiki skins don't use the 'ca-history' id.
		if ( historyAnchor.length ) {
			uri = historyAnchor.attr( 'href' );
			newUrl = $.trackActionURL( encodeURI(uri), generateEvent('history_tab_link-click') );
			historyAnchor.attr( 'href', newUrl );
		} else {
			uri = a.attr( 'href' );
		}

		// The tracking URL is generated by the click-tracking extension. It
		// will log the event and redirect the user to the history page.
		newUrl = $.trackActionURL( encodeURI(uri), generateEvent('timestamp_link-click') );

		// Inject the click-tracking redirect URL
		a.attr( 'href', newUrl );

		// Show the last modified message
		el.css( getStyleOverrides() ).show();

	} );
}

var article_in_sample = inSample( mw.config.get('wgArticleId').toString(), 0.006 );
var user_is_eligible = isEligible();

// Register the experiment as a campaign with the clicktracking extension
mw.activeCampaigns = mw.activeCampaigns || {};
mw.activeCampaigns.lastModified  = {
	name	: 'lastModified',
	version : VERSION,
	rates   : {
		// Bucket 50% of users into group
		expr1 : 1,
		ctrl1 : 1
	},
	expr1 : function () {
		bucket_name = 'expr1';
		if ( article_in_sample && user_is_eligible ) {
			mw.loader.using( 'last.modified', trackTimestamp );
		}
	},
	ctrl1 : function () {
		bucket_name = 'ctrl1';
	},
	allActive : function () {
		if ( article_in_sample && user_is_eligible ) {
			trackAction( generateEvent('impression') );
		}
	}
};
